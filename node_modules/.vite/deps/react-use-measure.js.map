{
  "version": 3,
  "sources": ["../../react-use-measure/src/index.ts"],
  "sourcesContent": ["import { useEffect, useState, useRef, useMemo } from 'react'\r\n\r\nfunction createDebounce<T extends (...args: any[]) => void>(callback: T, ms: number) {\r\n  let timeoutId: number\r\n\r\n  return (...args: Parameters<T>): void => {\r\n    window.clearTimeout(timeoutId)\r\n    timeoutId = window.setTimeout(() => callback(...args), ms)\r\n  }\r\n}\r\n\r\ndeclare type ResizeObserverCallback = (entries: any[], observer: ResizeObserver) => void\r\ndeclare class ResizeObserver {\r\n  constructor(callback: ResizeObserverCallback)\r\n  observe(target: Element, options?: any): void\r\n  unobserve(target: Element): void\r\n  disconnect(): void\r\n  static toString(): string\r\n}\r\n\r\nexport interface RectReadOnly {\r\n  readonly x: number\r\n  readonly y: number\r\n  readonly width: number\r\n  readonly height: number\r\n  readonly top: number\r\n  readonly right: number\r\n  readonly bottom: number\r\n  readonly left: number\r\n  [key: string]: number\r\n}\r\n\r\ntype HTMLOrSVGElement = HTMLElement | SVGElement\r\n\r\ntype Result = [(element: HTMLOrSVGElement | null) => void, RectReadOnly, () => void]\r\n\r\ntype State = {\r\n  element: HTMLOrSVGElement | null\r\n  scrollContainers: HTMLOrSVGElement[] | null\r\n  resizeObserver: ResizeObserver | null\r\n  lastBounds: RectReadOnly\r\n  orientationHandler: null | (() => void)\r\n}\r\n\r\nexport type Options = {\r\n  debounce?: number | { scroll: number; resize: number }\r\n  scroll?: boolean\r\n  polyfill?: { new (cb: ResizeObserverCallback): ResizeObserver }\r\n  offsetSize?: boolean\r\n}\r\n\r\nfunction useMeasure(\r\n  { debounce, scroll, polyfill, offsetSize }: Options = { debounce: 0, scroll: false, offsetSize: false },\r\n): Result {\r\n  const ResizeObserver =\r\n    polyfill || (typeof window === 'undefined' ? class ResizeObserver {} : (window as any).ResizeObserver)\r\n\r\n  if (!ResizeObserver) {\r\n    throw new Error(\r\n      'This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills',\r\n    )\r\n  }\r\n\r\n  const [bounds, set] = useState<RectReadOnly>({\r\n    left: 0,\r\n    top: 0,\r\n    width: 0,\r\n    height: 0,\r\n    bottom: 0,\r\n    right: 0,\r\n    x: 0,\r\n    y: 0,\r\n  })\r\n\r\n  // keep all state in a ref\r\n  const state = useRef<State>({\r\n    element: null,\r\n    scrollContainers: null,\r\n    resizeObserver: null,\r\n    lastBounds: bounds,\r\n    orientationHandler: null,\r\n  })\r\n\r\n  // set actual debounce values early, so effects know if they should react accordingly\r\n  const scrollDebounce = debounce ? (typeof debounce === 'number' ? debounce : debounce.scroll) : null\r\n  const resizeDebounce = debounce ? (typeof debounce === 'number' ? debounce : debounce.resize) : null\r\n\r\n  // make sure to update state only as long as the component is truly mounted\r\n  const mounted = useRef(false)\r\n  useEffect(() => {\r\n    mounted.current = true\r\n    return () => void (mounted.current = false)\r\n  })\r\n\r\n  // memoize handlers, so event-listeners know when they should update\r\n  const [forceRefresh, resizeChange, scrollChange] = useMemo(() => {\r\n    const callback = () => {\r\n      if (!state.current.element) return\r\n      const { left, top, width, height, bottom, right, x, y } =\r\n        state.current.element.getBoundingClientRect() as unknown as RectReadOnly\r\n\r\n      const size = {\r\n        left,\r\n        top,\r\n        width,\r\n        height,\r\n        bottom,\r\n        right,\r\n        x,\r\n        y,\r\n      }\r\n\r\n      if (state.current.element instanceof HTMLElement && offsetSize) {\r\n        size.height = state.current.element.offsetHeight\r\n        size.width = state.current.element.offsetWidth\r\n      }\r\n\r\n      Object.freeze(size)\r\n      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set((state.current.lastBounds = size))\r\n    }\r\n    return [\r\n      callback,\r\n      resizeDebounce ? createDebounce(callback, resizeDebounce) : callback,\r\n      scrollDebounce ? createDebounce(callback, scrollDebounce) : callback,\r\n    ]\r\n  }, [set, offsetSize, scrollDebounce, resizeDebounce])\r\n\r\n  // cleanup current scroll-listeners / observers\r\n  function removeListeners() {\r\n    if (state.current.scrollContainers) {\r\n      state.current.scrollContainers.forEach((element) => element.removeEventListener('scroll', scrollChange, true))\r\n      state.current.scrollContainers = null\r\n    }\r\n\r\n    if (state.current.resizeObserver) {\r\n      state.current.resizeObserver.disconnect()\r\n      state.current.resizeObserver = null\r\n    }\r\n\r\n    if (state.current.orientationHandler) {\r\n      if ('orientation' in screen && 'removeEventListener' in screen.orientation) {\r\n        screen.orientation.removeEventListener('change', state.current.orientationHandler)\r\n      } else if ('onorientationchange' in window) {\r\n        window.removeEventListener('orientationchange', state.current.orientationHandler)\r\n      }\r\n    }\r\n  }\r\n\r\n  // add scroll-listeners / observers\r\n  function addListeners() {\r\n    if (!state.current.element) return\r\n    state.current.resizeObserver = new ResizeObserver(scrollChange)\r\n    state.current.resizeObserver!.observe(state.current.element)\r\n    if (scroll && state.current.scrollContainers) {\r\n      state.current.scrollContainers.forEach((scrollContainer) =>\r\n        scrollContainer.addEventListener('scroll', scrollChange, { capture: true, passive: true }),\r\n      )\r\n    }\r\n\r\n    // Handle orientation changes\r\n    state.current.orientationHandler = () => {\r\n      scrollChange()\r\n    }\r\n\r\n    // Use screen.orientation if available\r\n    if ('orientation' in screen && 'addEventListener' in screen.orientation) {\r\n      screen.orientation.addEventListener('change', state.current.orientationHandler)\r\n    } else if ('onorientationchange' in window) {\r\n      // Fallback to orientationchange event\r\n      window.addEventListener('orientationchange', state.current.orientationHandler)\r\n    }\r\n  }\r\n\r\n  // the ref we expose to the user\r\n  const ref = (node: HTMLOrSVGElement | null) => {\r\n    if (!node || node === state.current.element) return\r\n    removeListeners()\r\n    state.current.element = node\r\n    state.current.scrollContainers = findScrollContainers(node)\r\n    addListeners()\r\n  }\r\n\r\n  // add general event listeners\r\n  useOnWindowScroll(scrollChange, Boolean(scroll))\r\n  useOnWindowResize(resizeChange)\r\n\r\n  // respond to changes that are relevant for the listeners\r\n  useEffect(() => {\r\n    removeListeners()\r\n    addListeners()\r\n  }, [scroll, scrollChange, resizeChange])\r\n\r\n  // remove all listeners when the components unmounts\r\n  useEffect(() => removeListeners, [])\r\n  return [ref, bounds, forceRefresh]\r\n}\r\n\r\n// Adds native resize listener to window\r\nfunction useOnWindowResize(onWindowResize: (event: Event) => void) {\r\n  useEffect(() => {\r\n    const cb = onWindowResize\r\n    window.addEventListener('resize', cb)\r\n    return () => void window.removeEventListener('resize', cb)\r\n  }, [onWindowResize])\r\n}\r\nfunction useOnWindowScroll(onScroll: () => void, enabled: boolean) {\r\n  useEffect(() => {\r\n    if (enabled) {\r\n      const cb = onScroll\r\n      window.addEventListener('scroll', cb, { capture: true, passive: true })\r\n      return () => void window.removeEventListener('scroll', cb, true)\r\n    }\r\n  }, [onScroll, enabled])\r\n}\r\n\r\n// Returns a list of scroll offsets\r\nfunction findScrollContainers(element: HTMLOrSVGElement | null): HTMLOrSVGElement[] {\r\n  const result: HTMLOrSVGElement[] = []\r\n  if (!element || element === document.body) return result\r\n  const { overflow, overflowX, overflowY } = window.getComputedStyle(element)\r\n  if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll')) result.push(element)\r\n  return [...result, ...findScrollContainers(element.parentElement)]\r\n}\r\n\r\n// Checks if element boundaries are equal\r\nconst keys: (keyof RectReadOnly)[] = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height']\r\nconst areBoundsEqual = (a: RectReadOnly, b: RectReadOnly): boolean => keys.every((key) => a[key] === b[key])\r\n\r\nexport default useMeasure\r\n"],
  "mappings": "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",
  "names": ["createDebounce", "callback", "ms", "timeoutId", "args", "useMeasure", "debounce", "scroll", "polyfill", "offsetSize", "ResizeObserver", "bounds", "set", "useState", "state", "useRef", "scrollDebounce", "resizeDebounce", "mounted", "useEffect", "forceRefresh", "resizeChange", "scrollChange", "useMemo", "left", "top", "width", "height", "bottom", "right", "x", "y", "size", "areBoundsEqual", "removeListeners", "element", "addListeners", "scrollContainer", "ref", "node", "findScrollContainers", "useOnWindowScroll", "useOnWindowResize", "onWindowResize", "cb", "onScroll", "enabled", "result", "overflow", "overflowX", "overflowY", "prop", "keys", "a", "b", "key"]
}
